AC_ISA(avr1){
  // sao 13 tipos básicos

  ac_format Type_RegDir_Rd  = "%rd_1:10 %op_1:6";

   /* ac_format Type_RegDir_Rr_Rd  = "%op_2:6 %r1:1 %rd_2:5 %r2:4"; */
  ac_format Type_RegDir_Rr_Rd  = "%r2:4 %rd_2:5 %r1:1 %op_2:6";
  
  /* ac_format Type_RegDir_Rd_Imm  = "%op_3:4 %k1:4 %rd_3:4 %k2:4"; */
  ac_format Type_RegDir_Rd_Imm  = "%k2:4 %rd_3:4 %k1:4 %op_3:4";

  /* ac_format Type_IO_Direct  = "%op_3:5 [%rd_3:5 | %rr:5] %addr:6"; */

  /* ac_format Type_Data_Direct_Addr  = "%op_4:12 [%rd_4:4 | %rr:4] %addr:16";// OBSERVE que sao 2 palavras de 16 bits.Observe q rd/rr tem 4 bits apenas(R16-R31).. */

  /* ac_format Type_Data_Indirect_With_Displacement  = "%op_5:5 [%rr:5 | %rd_5:5] %q:6 [%Y:16 | %Z:16]"; */
  //where is the opcode???
  /* ac_format Type_Data_Indirect_Addr_x  = "[%x:16 | %y:16 | %z:16]"; */
  
  /* //decrementa 1 antes de acessar a memoria */
  /* ac_format Type_Data_Indirect_With_Predecrement_Addr  = "[%x:16 | %y:16 | %z:16]"; */

  /* //incrementa 1 antes de acessar a memoria */
  /* ac_format Type_Data_Indirect_With_Preincrement_Addr  = "[%x:16 | %y:16 | %z:16]"; */

  
  /* //Program Memory Constant Addressing using the LPM, ELPM, and SPM Instructions NÂO IMPLEMENTADA */
  /* //Program Memory with Post-increment using the LPM Z+ and ELPM Z+ Instruction NÂO IMPLEMENTADA */
  
  /* //Direct Program Addressing, JMP and CALL, modifica o PC, 2 palavras, pula mais longe */
  /* ac_format Type_Direct_Program_Addressing  = "%op_6:10 %MSB:6 %LSD:16"; */
  
  /* //Indirect Program Addressing, IJMP and ICALL */
  /* ac_format Type_Indirect_Program_Addressing  = "%z:16"; */
  
  //Relative Program Addressing, RJMP and RCALL (PC <= PC+1+k), k vai de -2048 a +2047

  ac_format Type_Relative_Program_Addressing  = "%k_7:12 op_7:4";
  /* ac_format Type_Relative_Program_Addressing  = "%k_7:12 %op_7:4"; */
 
  //ac_format Type_Branches  = "%op_8:6 %k_8:7 %f:3";
  ac_format Type_Branches  = "%f:3 %k_8:7 %op_8:6";
  
  ac_format Type_A_Rr  = "%a2:4 %rd_9:5 %a1:2 %op_9:5";
  
  
  ac_instr<Type_RegDir_Rr_Rd> add, adc, sub, sbc, logical_and, logical_or, eor, mul, 
    mov,
    cp, cpc;// cpse;		
    

  ac_instr<Type_RegDir_Rd> rol, lsl, tst, clr;
  
  ac_instr<Type_RegDir_Rd_Imm> andi, ldi, cpi;
    //, ori, sbr, sbci, subi;

  ac_instr<Type_Relative_Program_Addressing> rjmp;

  ac_instr<Type_Branches> breq, brne, brge, brsh, brlo, brlt;

  ac_instr<Type_A_Rr> out;

  // default gas assembler uses numbers as register names
  ac_asm_map reg {
    "$"[0..31] = [0..31];
  }
  
  
  ISA_CTOR(avr1) {

    //out
    out.set_asm("out %imm, %reg", a1+a2, rd_9);
    out.set_decoder(op_9=0x17);

    //breq
    breq.set_asm("breq %imm", k_8);
    breq.set_decoder(op_8=0x3C, f=0x1);

    //brge
    brge.set_asm("brge %imm", k_8);
    brge.set_decoder(op_8=0x3D, f=0x4);

    //brlo
    brlo.set_asm("brlo %imm", k_8);
    brlo.set_decoder(op_8=0x3C, f=0x0);

    //brlt
    brlt.set_asm("brlt %imm", k_8);
    brlt.set_decoder(op_8=0x3C, f=0x4);
    
    //brne
    brne.set_asm("brne %imm", k_8);
    brne.set_decoder(op_8=0x3D, f=0x1);

    //brsh
    brsh.set_asm("brsh %imm", k_8);
    brsh.set_decoder(op_8=0x3D, f=0x0);

    //rol 
    rol.set_asm("rol %reg", rd_1);
    rol.set_decoder(op_1=0x7);

    //lsl
    lsl.set_asm("lsl %reg", rd_1);
    lsl.set_decoder(op_1=0x3);

    //tst
    tst.set_asm("tst %reg", rd_1);
    tst.set_decoder(op_1=0x8);

    //clr
    clr.set_asm("clr %reg", rd_1);
    clr.set_decoder(op_1=0x9);

    //add sem carry
    add.set_asm("add %reg, %reg", r1+r2, rd_2);
    add.set_decoder(op_2=0x3);

    //add com carry
    adc.set_asm("adc %reg, %reg", r1+r2, rd_2);
    adc.set_decoder(op_2=0x7);

    // logical and
    logical_and.set_asm("and %reg, %reg", r1+r2, rd_2);
    logical_and.set_decoder(op_2=0x8);
    
    // compare
    cp.set_asm("cp %reg, %reg", r1+r2, rd_2);
    cp.set_decoder(op_2=0x5);

    // compare with carry
    cpc.set_asm("cpc %reg, %reg", r1+r2, rd_2);
    cpc.set_decoder(op_2=0x1);
    
    /* // compare skip if equal */
    /* cpse.set_asm("cpse %reg, %reg", r1+r2, rd_2); */
    /* cpse.set_decoder(op_2=0x4); */

    // exclusive OR
    eor.set_asm("eor %reg, %reg", r1+r2, rd_2);
    eor.set_decoder(op_2=0x9);
    
    // mov
    mov.set_asm("mov %reg, %reg", r1+r2, rd_2);
    mov.set_decoder(op_2=0xB);
    
    // mul - unsigned
    mul.set_asm("mul %reg, %reg", r1+r2, rd_2);
    mul.set_decoder(op_2=0x27);

    // or - logical or
    logical_or.set_asm("or %reg, %reg", r1+r2, rd_2);
    logical_or.set_decoder(op_2=0xA);

    // sbc - subtract with carry
    sbc.set_asm("sbc %reg, %reg", r1+r2, rd_2);
    sbc.set_decoder(op_2=0x2);

    // sub- subtract without carry
    sub.set_asm("sub %reg, %reg", r1+r2, rd_2);
    sub.set_decoder(op_2=0x6);
    
    //andi
    andi.set_asm("andi %reg, %imm", rd_3, k1+k2);
    andi.set_decoder(op_3=0x7);
    
    /* //cbr */
    /* cbr.set_asm("cbr %reg, %imm", rd_3, k1+k2); */
    /* cbr.set_decoder(op_3=0x7); */
    
    //cpi
    cpi.set_asm("cpi %reg, %imm", rd_3, k1+k2);
    cpi.set_decoder(op_3=0x3);
    
    //ldi
    ldi.set_asm("ldi %reg, %imm", rd_3, k1+k2);
    ldi.set_decoder(op_3=0xE);
    
    /* //ori */
    /* ori.set_asm("ori %reg, %imm", rd_3, k1+k2); */
    /* ori.set_decoder(op_3=0x6); */
    
    /* //sbr */
    /* sbr.set_asm("sbr %reg, %imm", rd_3, k1+k2); */
    /* sbr.set_decoder(op_3=0x6); */
    
    /* //sbci */
    /* sbci.set_asm("sbci %reg, %imm", rd_3, k1+k2); */
    /* sbci.set_decoder(op_3=0x4); */
    
    /* //subi */
    /* subi.set_asm("subi %reg, %imm", rd_3, k1+k2); */
    /* subi.set_decoder(op_3=0x5); */

    //relative jump
    rjmp.set_asm("rjmp %imm", k_7);
    rjmp.set_decoder(op_7=0xC);


  };


};
	

