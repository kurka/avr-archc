AC_ISA(avr1){
  // sao 13 tipos básicos

  ac_format Type_RegDir_Rd  = "%op_1:6 %rd_1:10";

  ac_format Type_RegDir_Rr_Rd  = "%op_2:6 %r1:1 %rd_2:5 %r2:4";
  
  ac_format Type_RegDir_Rr_Rd  = "%op_3:4 %k1:4 %rd_3:4 %k2:4";

  /* ac_format Type_IO_Direct  = "%op_3:5 [%rd_3:5 | %rr:5] %addr:6"; */

  /* ac_format Type_Data_Direct_Addr  = "%op_4:12 [%rd_4:4 | %rr:4] %addr:16";// OBSERVE que sao 2 palavras de 16 bits.Observe q rd/rr tem 4 bits apenas(R16-R31).. */

  /* ac_format Type_Data_Indirect_With_Displacement  = "%op_5:5 [%rr:5 | %rd_5:5] %q:6 [%Y:16 | %Z:16]"; */
  //where is the opcode???
  /* ac_format Type_Data_Indirect_Addr_x  = "[%x:16 | %y:16 | %z:16]"; */
  
  /* //decrementa 1 antes de acessar a memoria */
  /* ac_format Type_Data_Indirect_With_Predecrement_Addr  = "[%x:16 | %y:16 | %z:16]"; */

  /* //incrementa 1 antes de acessar a memoria */
  /* ac_format Type_Data_Indirect_With_Preincrement_Addr  = "[%x:16 | %y:16 | %z:16]"; */

  
  /* //Program Memory Constant Addressing using the LPM, ELPM, and SPM Instructions NÂO IMPLEMENTADA */
  /* //Program Memory with Post-increment using the LPM Z+ and ELPM Z+ Instruction NÂO IMPLEMENTADA */
  
  /* //Direct Program Addressing, JMP and CALL, modifica o PC, 2 palavras, pula mais longe */
  /* ac_format Type_Direct_Program_Addressing  = "%op_6:10 %MSB:6 %LSD:16"; */
  
  /* //Indirect Program Addressing, IJMP and ICALL */
  /* ac_format Type_Indirect_Program_Addressing  = "%z:16"; */
  
  /* //Relative Program Addressing, RJMP and RCALL (PC <= PC+1+k), k vai de -2048 a +2047 */
  /* ac_format Type_Relative_Program_Addressing  = "%op_7:4 %k:12"; */
  
  
  
  ac_instr<Type_RegDir_Rr_Rd> add, adc, sub, sbc, logical_and, logical_or, eor, mul, 
    mov,
    cp, cpc;// cpse;		
    

  ac_instr<Type_RegDir_Rd> rol, lsl, tst, clr;
  
  ac_instr<Type_RegDir_Rd> andi, cbr, cpi, ldi, ori, sbr, sbci, subi;

  // default gas assembler uses numbers as register names
  ac_asm_map reg {
    "$"[0..31] = [0..31];
  }
  
  
  ISA_CTOR(avr1) {
    //rol 
    rol.set_asm("rol %reg", rd_1);
    rol.set_decoder(op_1=0x7);

    //lsl
    lsl.set_asm("lsl %reg", rd_1);
    lsl.set_decoder(op_1=0x3);

    //tst
    tst.set_asm("tst %reg", rd_1);
    tst.set_decoder(op_1=0x8);

    //clr
    clr.set_asm("clr %reg", rd_1);
    clr.set_decoder(op_1=0x9);

    //add sem carry
    add.set_asm("add %reg, %reg", r1+r2, rd_2);
    add.set_decoder(op_2=0x3);

    //add com carry
    adc.set_asm("adc %reg, %reg", r1+r2, rd_2);
    adc.set_decoder(op_2=0x7);

    // logical and
    logical_and.set_asm("and %reg, %reg", r1+r2, rd_2);
    logical_and.set_decoder(op_2=0x8);
    
    // compare
    cp.set_asm("cpc %reg, %reg", r1+r2, rd_2);
    cp.set_decoder(op_2=0x5);

    // compare with carry
    cpc.set_asm("cpc %reg, %reg", r1+r2, rd_2);
    cpc.set_decoder(op_2=0x1);
    
    /* // compare skip if equal */
    /* cpse.set_asm("cpse %reg, %reg", r1+r2, rd_2); */
    /* cpse.set_decoder(op_2=0x4); */

    // exclusive OR
    eor.set_asm("eor %reg, %reg", r1+r2, rd_2);
    eor.set_decoder(op_2=0x9);
    
    // mov
    mov.set_asm("mov %reg, %reg", r1+r2, rd_2);
    mov.set_decoder(op_2=0xB);
    
    // mul - unsigned
    mul.set_asm("mul %reg, %reg", r1+r2, rd_2);
    mul.set_decoder(op_2=0x27);

    // or - logical or
    logical_or.set_asm("or %reg, %reg", r1+r2, rd_2);
    logical_or.set_decoder(op_2=0xA);

    // sbc - subtract with carry
    sbc.set_asm("sbc %reg, %reg", r1+r2, rd_2);
    sbc.set_decoder(op_2=0x2);

    // sub- subtract without carry
    sub.set_asm("sub %reg, %reg", r1+r2, rd_2);
    sub.set_decoder(op_2=0x6);
    
	//andi 
    andi.set_asm("subi %reg, %imm", rd_1, k1+k2);
    andi.set_decoder(op_3=0x7);
    
    //cbr 
    cbr.set_asm("subi %reg, %imm", rd_1, k1+k2);
    cbr.set_decoder(op_3=0x7);
    
    //cpi 
    cpi.set_asm("subi %reg, %imm", rd_1, k1+k2);
    cpi.set_decoder(op_3=0x3);
    
    //ldi 
    ldi.set_asm("subi %reg, %imm", rd_1, k1+k2);
    ldi.set_decoder(op_3=0x14);
    
    //ori 
    ori.set_asm("subi %reg, %imm", rd_1, k1+k2);
    ori.set_decoder(op_3=0x6);
    
    //sbr 
    sbr.set_asm("subi %reg, %imm", rd_1, k1+k2);
    sbr.set_decoder(op_3=0x6);
    
    //sbci 
    sbci.set_asm("subi %reg, %imm", rd_1, k1+k2);
    sbci.set_decoder(op_3=0x4);
    
    //subi 
    subi.set_asm("subi %reg, %imm", rd_1, k1+k2);
    subi.set_decoder(op_3=0x5);

  };


};
	

